
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://yanggang.site/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://yanggang.site/theme/pygments/xcode.min.css">
  <link rel="stylesheet" type="text/css" href="http://yanggang.site/theme/font-awesome/css/font-awesome.min.css">

    <link href="http://yanggang.site/static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="http://yanggang.site/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="http://yanggang.site/images/favicon.ico" type="image/x-icon">


    <!-- Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="#333">
    <!-- Windows Phone -->
    <meta name="msapplication-navbutton-color" content="#333">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Microsoft EDGE -->
    <meta name="msapplication-TileColor" content="#333">

<meta name="author" content="gianarb" />
<meta name="description" content="本文是一篇关于 Go 语言和正向代理的译文，版权归原作者所有，转载请注明出处。" />
<meta name="keywords" content="Go">

<meta property="og:site_name" content="东坡烟尘"/>
<meta property="og:title" content="（译文）如何用go语言实现正向代理"/>
<meta property="og:description" content="本文是一篇关于 Go 语言和正向代理的译文，版权归原作者所有，转载请注明出处。"/>
<meta property="og:locale" content="zh_CN"/>
<meta property="og:url" content="http://yanggang.site/go_forward_proxy.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-03-23 20:22:00+08:00"/>
<meta property="article:modified_time" content="2018-03-23 22:10:00+08:00"/>
<meta property="article:author" content="http://yanggang.site/author/gianarb.html">
<meta property="article:section" content="计算机"/>
<meta property="article:tag" content="Go"/>
<meta property="og:image" content="http://p5kcj7ax4.bkt.clouddn.com/img/profile.png">

  <title>东坡烟尘 &ndash; （译文）如何用go语言实现正向代理</title>

</head>
<body>
  <aside>
    <div>
      <a href="http://yanggang.site">
        <img src="http://p5kcj7ax4.bkt.clouddn.com/img/profile.png" alt="东坡烟尘" title="东坡烟尘">
      </a>
      <h1><a href="http://yanggang.site">东坡烟尘</a></h1>

<p>静能生悟，即鸟啼花落，都是化机。</p>
      <nav>
        <ul class="list">
          <li><a href="http://yanggang.site/pages/about.html#about">关于</a></li>

        </ul>
      </nav>

      <ul class="social">
        <li><a class="sc-github" href="https://github.com/vincent08" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="https://stackoverflow.com/users/9515040/yanggang" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href="http://yanggang.site">主页</a>

      <a href="/archives.html">归档</a>
      <a href="/categories.html">分类</a>
      <a href="/tags.html">标签</a>


    </nav>

<article class="single">
  <header>
      
    <h1 id="go_forward_proxy">（译文）如何用go语言实现正向代理</h1>
    <p>
      在 五 23 三月 2018 发布于 <a href="http://yanggang.site/category/ji-suan-ji.html">计算机</a> 分类

    </p>
  </header>


  <div>
    <p>正向代理是处理一组内网客户端发往外部机器的网络请求的一种代理方式。</p>
<p>实际上，正向代理是你的应用和你所要连接的服务器之间的中间人。它在 HTTP(S) 协议上起作用，并且被部署在网络设施的边缘。</p>
<p>你通常可以在大型组织或大学中见到正向代理，它被用来进行授权管理或网络安全方面的控制。</p>
<p>我发现在使用容器或者动态的云环境工作时，正向代理很有用，因为你会面临一组服务器和外部网络的通信问题。</p>
<p>如果你在 AWS、AZure 之类的动态环境下工作，你会拥有一批数量不定的服务器和一批数量不定的公网 IP。你把应用运行在 Kubernetes 集群上时也是一样，容器可能遍布四处。</p>
<p>现在假设有客户让你提供一个公网 IP 的范围，因为他需要设置防火墙。你如何提供这个特性呢？这个问题有些情况下很简单，有些情况下可能非常复杂。</p>
<p>2015年12月1日，有一位用户在 <a href="https://discuss.circleci.com/t/circleci-source-ip/1202">CircleCI 论坛</a>上提了这个问题，并且问题还未关闭。当然，CircleCI 很棒。我只是举个例子，并非要埋怨他们。</p>
<p>解决这个问题的一种可行方法是使用正向代理。你可以让一组节点以同一静态IP运转，然后把清单提供给客户即可。</p>
<p>几乎所有云服务提供商都是这样做的，比如 DigitalOcean 的浮动IP（floating IP）、AWS的弹性IP（elastic IP）等。</p>
<p>你可以通过配置自己的应用来把请求转发到这个（代理）池中。这样，终点的服务所取得的IP就是正向代理节点的IP，而不是内部IP。</p>
<p>正向代理可以成为你的网络设施的又一安全层，因为你可以在一个中心化的地方极其方便地扫描和控制内部网络发出来的数据包。</p>
<p>正向代理不会带来单点故障，因为你可以运行多个正向代理服务，他们具有很好的伸缩性。</p>
<p>在底层，HTTP 的 <code>CONNECT</code> 方法就是一种正向代理。</p>
<blockquote>
<p>CONNECT 方法将请求连接转化为透明 TCP/IP 通道，通常用于在未加密的 HTTP 代理上进行 SSL 加密的通信（HTTPS）。</p>
</blockquote>
<p>很多用各种语言写成的 HTTP 客户端已经以透明的方式支持这个功能了。在此，我以一个使用 Go 语言和 <a href="https://www.privoxy.org/">privoxy</a> 的小例子来告诉大家，这很简单。</p>
<p>首先，我们创建一个名为<code>whoyare</code>的应用。它是一个 HTTP 服务器，功能是返回你的远程地址。</p>
<div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s2">&quot;encoding/json&quot;</span>
    <span class="s2">&quot;net/http&quot;</span>
<span class="p">)</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">http</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="s2">&quot;/whoyare&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span><span class="o">.</span><span class="n">Header</span><span class="p">()</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="s2">&quot;Content-Type&quot;</span><span class="p">,</span> <span class="s2">&quot;application/json&quot;</span><span class="p">)</span>
        <span class="n">body</span><span class="p">,</span> <span class="n">_</span> <span class="p">:</span><span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">Marshal</span><span class="p">(</span><span class="nb">map</span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="n">string</span><span class="p">{</span>
            <span class="s2">&quot;addr&quot;</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">RemoteAddr</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="n">http</span><span class="o">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s2">&quot;:8080&quot;</span><span class="p">,</span> <span class="n">nil</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>如果用<code>GET</code>方法访问路径<code>/whoyare</code>，你会得到一个类似下面的JSON格式的响应：<code>{"addr": "34.35.23.54"}</code>，其中<code>34.35.23.54</code>就是你的公网地址。如果你使用的是笔记本电脑，那么在终端上发出请求后，你应该会得到<code>localhost</code>的结果。可以用<code>curl</code>来试一下：</p>
<div class="highlight"><pre><span></span><span class="mi">18</span><span class="o">:</span><span class="mi">36</span> <span class="n">$</span> <span class="n">curl</span> <span class="o">-</span><span class="n">v</span> <span class="n">http</span><span class="o">://</span><span class="n">localhost</span><span class="o">:</span><span class="mi">8080</span><span class="o">/</span><span class="n">whoyare</span>
<span class="o">*</span> <span class="n">TCP_NODELAY</span> <span class="kd">set</span>
<span class="o">&gt;</span> <span class="n">GET</span> <span class="sr">/whoyare HTTP/</span><span class="mf">1.1</span>
<span class="o">&gt;</span> <span class="n">User</span><span class="o">-</span><span class="n">Agent</span><span class="o">:</span> <span class="n">curl</span><span class="o">/</span><span class="mf">7.58</span><span class="o">.</span><span class="mi">0</span>
<span class="o">&gt;</span> <span class="n">Accept</span><span class="o">:</span> <span class="o">*/*</span>
<span class="o">&gt;</span>
<span class="o">&lt;</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">200</span> <span class="n">OK</span>
<span class="o">&lt;</span> <span class="n">Content</span><span class="o">-</span><span class="n">Type</span><span class="o">:</span> <span class="n">application</span><span class="o">/</span><span class="n">json</span>
<span class="o">&lt;</span> <span class="n">Date</span><span class="o">:</span> <span class="n">Sun</span><span class="o">,</span> <span class="mi">18</span> <span class="n">Mar</span> <span class="mi">2018</span> <span class="mi">17</span><span class="o">:</span><span class="mi">36</span><span class="o">:</span><span class="mi">40</span> <span class="n">GMT</span>
<span class="o">&lt;</span> <span class="n">Content</span><span class="o">-</span><span class="n">Length</span><span class="o">:</span> <span class="mi">31</span>
<span class="o">&lt;</span>
<span class="o">*</span> <span class="n">Connection</span> <span class="err">#</span><span class="mi">0</span> <span class="n">to</span> <span class="n">host</span> <span class="n">localhost</span> <span class="n">left</span> <span class="n">intact</span>
<span class="o">{</span><span class="s2">&quot;addr&quot;</span><span class="o">:</span><span class="s2">&quot;localhost:38606&quot;</span><span class="o">}</span>
</pre></div>


<p>我写了另外一个程序，它用<code>http.Client</code>在标准输出上打印响应。你可以在已经运行了<code>whoyare</code>服务的前提下运行这个程序：</p>
<div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s2">&quot;io/ioutil&quot;</span>
    <span class="s2">&quot;log&quot;</span>
    <span class="s2">&quot;net/http&quot;</span>
    <span class="s2">&quot;os&quot;</span>
<span class="p">)</span>

<span class="nb">type</span> <span class="n">whoiam</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">Addr</span> <span class="n">string</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">url</span> <span class="p">:</span><span class="o">=</span> <span class="s2">&quot;http://localhost:8080&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;&quot;</span> <span class="o">!=</span> <span class="n">os</span><span class="o">.</span><span class="n">Getenv</span><span class="p">(</span><span class="s2">&quot;URL&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Getenv</span><span class="p">(</span><span class="s2">&quot;URL&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;Target </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
    <span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;/whoyare&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">Error</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="n">defer</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="n">body</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">ioutil</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">Error</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;You are &quot;</span> <span class="o">+</span> <span class="n">string</span><span class="p">(</span><span class="n">body</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<p>这是个很简单的例子，但是你可以将其运用在很多复杂场合。</p>
<p>为了让例子更清楚，我在 DigitalOcean 上创建了两台虚拟机：一台运行<code>privoxy</code>，另一台运行<code>whoyare</code>。</p>
<ul>
<li>whoyare: public ip 188.166.17.88</li>
<li>privoxy: public ip 167.99.41.79</li>
</ul>
<p>Privoxy 是一个易用的正向代理。相比而言，Nginx 和 Haproxy 都不太适合在这种场景下使用，因为它们不支持<code>CONNECT</code>方法。</p>
<p>我在 Docker Hub 上创建了一个 docker 镜像，你可以直接运行它，默认使用端口 8118。</p>
<div class="highlight"><pre><span></span>core@coreos-s-1vcpu-1gb-ams3-01 ~ $ docker run -it --rm -p 8118:8118
gianarb/privoxy:latest
2018-03-18 17:28:05.589 7fbbf41dab88 Info: Privoxy version 3.0.26
2018-03-18 17:28:05.589 7fbbf41dab88 Info: Program name: privoxy
2018-03-18 17:28:05.591 7fbbf41dab88 Info: Loading filter file:
/etc/privoxy/default.filter
2018-03-18 17:28:05.599 7fbbf41dab88 Info: Loading filter file:
/etc/privoxy/user.filter
2018-03-18 17:28:05.599 7fbbf41dab88 Info: Loading actions file:
/etc/privoxy/match-all.action
2018-03-18 17:28:05.600 7fbbf41dab88 Info: Loading actions file:
/etc/privoxy/default.action
2018-03-18 17:28:05.607 7fbbf41dab88 Info: Loading actions file:
/etc/privoxy/user.action
2018-03-18 17:28:05.611 7fbbf41dab88 Info: Listening on port 8118 on IP address
0.0.0.0
</pre></div>


<p>第二步，编译<code>whoyare</code>并且把可执行文件用scp传送到服务器，可使用以下命令：</p>
<div class="highlight"><pre><span></span>$ <span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> <span class="nv">GOOS</span><span class="o">=</span>linux go build -o bin/server_linux -a ./whoyare
</pre></div>


<p>应用运行起来之后，我们就可以用 cURL 来直接或者通过 privoxy 发送请求了。</p>
<p>直接发送请求如下：</p>
<div class="highlight"><pre><span></span>$ curl -v http://your-ip:8080/whoyare
</pre></div>


<p>cURL 使用环境变量<code>http_proxy</code>来配置代理进行请求转发：</p>
<div class="highlight"><pre><span></span>$ <span class="nv">http_proxy</span><span class="o">=</span>http://167.99.41.79:8118 curl -v http://188.166.17.88:8080/whoyare
*   Trying <span class="m">167</span>.99.41.79...
* TCP_NODELAY <span class="nb">set</span>
* Connected to <span class="m">167</span>.99.41.79 <span class="o">(</span><span class="m">167</span>.99.41.79<span class="o">)</span> port <span class="m">8118</span> <span class="o">(</span><span class="c1">#0)</span>
&gt; GET http://188.166.17.88:8080/whoyare HTTP/1.1
&gt; Host: <span class="m">188</span>.166.17.88:8080
&gt; User-Agent: curl/7.58.0
&gt; Accept: */*
&gt; Proxy-Connection: Keep-Alive
&gt;
&lt; HTTP/1.1 <span class="m">200</span> OK
&lt; Content-Type: application/json
&lt; Date: Sun, <span class="m">18</span> Mar <span class="m">2018</span> <span class="m">17</span>:37:02 GMT
&lt; Content-Length: <span class="m">29</span>
&lt; Proxy-Connection: keep-alive
&lt;
* Connection <span class="c1">#0 to host 167.99.41.79 left intact</span>
<span class="o">{</span><span class="s2">&quot;addr&quot;</span>:<span class="s2">&quot;167.99.41.79:58920&quot;</span><span class="o">}</span>
</pre></div>


<p>如你所见，我设置了<code>http_proxy=http://167.99.41.79:8118</code>之后，响应不再包含我的公网IP了，而是代理的IP。</p>
<p>privoxy 处应该会留下如下的请求日志：</p>
<div class="highlight"><pre><span></span>2018-03-18 17:28:22.886 7fbbf41d5ae8 Request: 188.166.17.88:8080/whoyare
2018-03-18 17:32:29.495 7fbbf41d5ae8 Request: 188.166.17.88:8080/whoyare
</pre></div>


<p>你之前运行的客户端默认连接到<code>localhost:8080</code>，但可以通过设置环境变量<code>URL=http://188.166.17.88:8080</code>来覆盖目标地址。运行以下命令可以直接到达<code>whoyare</code>。</p>
<div class="highlight"><pre><span></span>$ <span class="nv">URL</span><span class="o">=</span>http://188.166.17.88:8080 ./bin/client_linux
<span class="m">2018</span>/03/18 <span class="m">18</span>:37:59 Target http://188.166.17.88:8080.
You are <span class="o">{</span><span class="s2">&quot;addr&quot;</span>:<span class="s2">&quot;95.248.202.252:38620&quot;</span><span class="o">}</span>
</pre></div>


<p>Go语言的<code>HTTP.Client</code>包支持一组和代理相关的环境变量，设置这些环境变量可以对运行期间的服务立刻生效，十分灵活。</p>
<div class="highlight"><pre><span></span>export HTTP_PROXY=http://http_proxy:port/
export HTTPS_PROXY=http://https_proxy:port/
export NO_PROXY=127.0.0.1, localhost
</pre></div>


<p>前两个环境变量很简单，一个是HTTP代理，一个是HTTPS代理。<code>NO_PROXY</code>排除了一组主机名，当要访问的主机在这个清单里的时候，请求不经过代理。我这里配置的是<code>localhost</code>和 127.0.0.1。</p>
<div class="highlight"><pre><span></span>HTT_PROXY=http://forwardproxy:8118
     +--------------+           +----------------+         +----------------+
     |              |           |                |         |                |
     |   client     +----------^+ forward proxy  +--------^+    whoyare     |
     |              |           |                |         |                |
     +--------------+           +----------------+         +----^-----------+
                                                                |
                                                                |
    +---------------+                                           |
    |               |                                           |
    |   client      +-------------------------------------------+
    |               |
    +---------------+
   HTTP_PROXY not configured
</pre></div>


<p>配置了环境变量的客户端将会通过代理访问，其他客户端将直接访问。</p>
<p>这个控制粒度很重要。你不仅可以按进程去控制是否经过代理，还可以按请求去控制，十分灵活。</p>
<div class="highlight"><pre><span></span>$ <span class="nv">HTTP_PROXY</span><span class="o">=</span>http://167.99.41.79:8118 <span class="nv">URL</span><span class="o">=</span>http://188.166.17.88:8080
./bin/client_linux
<span class="m">2018</span>/03/18 <span class="m">18</span>:39:18 Target http://188.166.17.88:8080.
You are <span class="o">{</span><span class="s2">&quot;addr&quot;</span>:<span class="s2">&quot;167.99.41.79:58922&quot;</span><span class="o">}</span>
</pre></div>


<p>可以看到，我们通过代理到达了<code>whoyare</code>，响应中的<code>addr</code>是代理的地址。</p>
<p>最后一个命令有些怪异，但它只是为了展示<code>NO_PROXY</code>是如何工作的。我们在设置访问代理的同时，排除了<code>whoyare</code>的 URL。正如我们期望的那样，请求没有经过代理：</p>
<div class="highlight"><pre><span></span>$ <span class="nv">HTTP_PROXY</span><span class="o">=</span>http://167.99.41.79:8118 <span class="nv">URL</span><span class="o">=</span>http://188.166.17.88:8080 <span class="nv">NO_PROXY</span><span class="o">=</span><span class="m">188</span>.166.17.88 ./bin/client_linux
<span class="m">2018</span>/03/18 <span class="m">18</span>:42:03 Target http://188.166.17.88:8080.
You are <span class="o">{</span><span class="s2">&quot;addr&quot;</span>:<span class="s2">&quot;95.248.202.252:38712&quot;</span><span class="o">}</span>
</pre></div>


<p>本文应作为 Go 语言和正向代理的实用介绍来阅读。你可以订阅我的<a href="https://gianarb.it/atom.xml">rss</a>，或者在<a href="https://twitter.com/gianarb">twitter</a>上关注我。兴许我以后还会介绍如何用 Go 替代 privoxy 以及如何在 Kubernetes 集群上部署。所以，快告诉我先写哪部分吧！</p>
<hr>
<p>via: <a href="https://gianarb.it/blog/golang-forwarding-proxy">原文链接</a></p>
<p>作者：<a href="https://github.com/gianarb">gianarb</a>
译者：<a href="https://github.com/vincent08">vincent08</a></p>
<hr>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://yanggang.site/tag/go.html">Go</a>
    </p>
  </div>





<!-- Disqus -->
<div align="center"> <font color=grey>由于网络原因，国内用户可能无法评论。</font></div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'yanggang-site';
    
    //页面完全加载完成后，再执行脚本，避免浏览器一直转圈 

    var screen = window.screen.height;//可视区域高度
    var compare = document.body.clientHeight-document.body.scrollTop;//可视区域顶部距离整个网页的底部距离

    if(screen+10 >= compare){
        function comment_fun() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }
        setTimeout(comment_fun,3000);  // 延迟3s执行
    }  
</script>
<noscript>
    请启用浏览器的Javascript功能以查看评论。
</noscript>
<!-- End Disqus -->
</article>

<!-- add by yanggang -->
<a id="gotop" href="#">   
  <span>▲</span> 
</a>


    <footer>
<p>交友须带三分侠气，做人要存一点素心。</p>
<p>E-mail: yanggang@yanggang.site</p>
<p>Copyright 2016 - 2018 东坡烟尘.</p>
<!-- <p>&copy; 东坡烟尘 2018</p> -->
<!-- <p>本站由 <a href="http://getpelican.com" target="_blank">Pelican</a> 驱动，并使用了 <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a> 开发的 <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> 主题。</p> -->
<br>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " 东坡烟尘 ",
  "url" : "http://yanggang.site",
  "image": "http://p5kcj7ax4.bkt.clouddn.com/img/profile.png",
  "description": "Personal Thoughts and Writings"
}
</script>

</body>
</html>