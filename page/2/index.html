<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="东坡烟尘">
<meta property="og:url" content="http://yanggang.site/page/2/index.html">
<meta property="og:site_name" content="东坡烟尘">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="东坡烟尘">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yanggang.site/page/2/"/>





  <title>东坡烟尘</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">东坡烟尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">静能生悟，即鸟啼花落，都是化机。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yanggang.site/2016/09/07/database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="东坡烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/07/database/" itemprop="url">
                  数据库要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-07T18:59:55+08:00">
                2016-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  数据库(Database)是按照数据结构来组织、存储和管理数据的仓库，它产生于距今六十多年前，随着信息技术和市场的发展，特别是二十世纪九十年代以后，数据管理不再仅仅是存储和管理数据，而转变成用户所需要的各种数据管理的方式。数据库有很多种类型，从最简单的存储有各种数据的表格到能够进行海量数据存储的大型数据库系统都在各个方面得到了广泛的应用。</p>
<ol>
<li><p>索引的类型:<br> (1) 唯一索引<br> (2) 非唯一索引<br> (3) 主键索引<br> (4) 聚集索引</p>
</li>
<li><p>主键与索引的区别:<br> (1) 主键一般在创建表的时候指定，而索引可以在任何时候创建；<br> (2) 一个表只能有一个主键，但可以有多个索引；<br> (3) 主键也是一种索引，但索引不是主键;<br> (4) 索引可以创建也可以删除。</p>
<p> 参考资料：Mysql索引详解大全<br> <a href="http://www.cnblogs.com/renfanzi/p/5742650.html" target="_blank" rel="external">http://www.cnblogs.com/renfanzi/p/5742650.html</a></p>
</li>
<li><p>C语言操作库函数：</p>
<p> <a href="http://blog.csdn.net/caisini_vc/article/details/38271991" target="_blank" rel="external">http://blog.csdn.net/caisini_vc/article/details/38271991</a></p>
<p> 特别注意：<br> （1）对于包含二进制数据的查询，必须使用 mysql_real_query()，而不是 mysql_query()，因为二进制代码数据可能包含“ \0”字符，而且前者比后者查询更快，因为它不会在查询字符串上调用 strlen()。项目中尽量使用前者。<br> （2）执行查询指令之后，再用 mysql_store_result() 函数获取查询结果。此函数返回的是结构指针，后面还需要用代码把结构的内容读到自己的程序里来。对于大的结果集，该函数所需的内存可能很大，甚至发生内存溢出。<br> （3）获取结果集之后，再用mysql_fetch_row() 循环读出每一行，该函数返回一个数组。<br> （4）mysql_commit() 提交事务，mysql_rollback() 回滚事务。</p>
</li>
<li><p>商用系统部分设计要点（以员工管理系统为例）<br>（1）包含两大模块：平台模块（实现通用功能如配置文件、日志、数据库操作接口等）和业务模块（实现员工管理业务）。<br>（2）配置文件一般要做到接口可以被各个子模块访问。配置数据应分为整数和字符串。配置文件的格式一般遵循 [module] config=value 的语法。<br>（3）日志信息非常有用，一般而言应该打印在日志文件中的信息包括：（a）系统日志信息（如各模块的启动信息）；（b）错误日志信息；（c）告警日志信息（比如系统最多支持1000个员工，当使用达到900人时发出告警）；（d）调试日志信息（或叫消息日志信息）。对应地，把上述四类信息定义为4个级别：系统日志级别、错误日志级别、告警日志级别、消息日志级别。交付给用户时只留下系统日志和错误日志。一般应允许用户在配置文件中修改日志级别。<br>（4）日志模块的接口要考虑通用性，因为各个业务模块要打印的信息可能结构不同，有整数、字符串等信息。每个模块调用时都可以选择自己的打印级别。<br>（5）日志模块要考虑文件系统允许的最大文件大小，比如可能有些系统限制最大2G，这时候要新建日志文件并将过去的日志按日期重命名整理。<br>（6）写日志的任务应该放到链表（异步任务队列），避免影响业务模块的性能。<br>（7）日志是独立的文件，应该单独占用一个目录 ./log/ 。</p>
</li>
<li><p>以Log4j为例，日志记录器（Logger）的行为是分等级的。具体分为：OFF、 FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL或者您定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别， 则应用程序中所有DEBUG级别的日志信息将不被打印出来。程序会打印高于或等于所 设置级别的日志，设置的日志等级越高，打印出来的日志就越少。如果设置级别为INFO，则优先级高于等于INFO级别（如：INFO、 WARN、ERROR）的日志信息将可以被输出,小于该级别的如DEBUG将不会被输出。</p>
</li>
<li><p>Python项目中日志文件的配置方法：<br> <a href="http://python.jobbole.com/81666/" target="_blank" rel="external">http://python.jobbole.com/81666/</a></p>
</li>
</ol>
<ol>
<li><p>一个会话至少包含一个连接，可以完成多个事务。</p>
</li>
<li><p>高并发的概念：高并发是指多个线程同时调用你的接口的时候不会发生错误。</p>
<blockquote>
<p>面试: 你的数据库怎么支持高并发和异步操作？（通过句柄的方式）</p>
</blockquote>
</li>
<li><p>在demo中，业务模块与数据库模块的操作是通过一个双向链表进行的。一般而言我们在项目中，每个模块的交互都是采用双向链表的方式。<br> 为什么业务模块不直接操作mysql数据库，而是把数据同步到链表之后来操作链表呢？<br> 理论上，业务层完全不需要建立一个链表来同步数据库，这样不仅简单，而且容易维护。但是，这样设计最大的弱点是，性能很慢。如果有1000个用户同时查询员工信息，每次都从mysql数据库获取，性能很差。所以在内存中建立缓存，可提高性能。<br> 当然，并不是一定要加缓存，很多小型商业项目或企业内部项目（并发基本不会太多）就完全没有缓存的概念。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yanggang.site/2016/09/05/processAndThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="东坡烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/05/processAndThread/" itemprop="url">
                  进程与线程要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-05T18:58:22+08:00">
                2016-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进程（process）和线程（thread）是操作系统的基本概念。它们是两种不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ol>
<li><p>在Linux中，当用户注销或者网络断开时，终端会收到HUP（hang up）信号，从而关闭其所有子进程。那么如何让程序不随着终端的关闭而停止运行呢？两个思路：（1）让进程忽略HUP信号:  比如<code>nohup ./process01 &amp;</code>  ;（2）让进程运行在新的会话里，从而成为不属于此终端的子进程：比如 <code>setsid ./process01</code> 或者 <code>(./process01 &amp;)</code> 。</p>
<blockquote>
<p>将一个或多个命令包含在小括号中就能让这些命令在子shell中运行，从而扩展出很多有趣的功能。<br>Linux下第一个用户进程是init，它的进程号是1。</p>
</blockquote>
</li>
<li><p>创建线程的库 pthread.h 不是linux系统的默认库，所以编译时要上库的名称作为参数，即<code>gcc process.c -lpthread</code>.<br>线程创建函数为 <code>thread_create</code>，第一个参数为指向线程标志符的指针，第二个参数用来设置线程属性，第三个参数是线程运行函数的起始地址，最后一个参数是运行函数的参数。详细参考文章： <a href="http://www.cnblogs.com/wainiwann/p/3550748.html" target="_blank" rel="external">http://www.cnblogs.com/wainiwann/p/3550748.html</a></p>
</li>
<li><p>操作系统资源分配的基本单位是进程， 处理器调度的基本单位是线程。<br>现代操作系统的时间分片调度是以线程（而不是进程）为最小单位的，程序中定义的全局变量，在每个线程都可以直接进行读写。这个在面试中经常涉及。</p>
</li>
<li><p>线程退出有三种形式：（1）线程函数执行完毕后退出，（2）被同一进程的其他线程取消，pthread_cancel（3）线程调用 pthread_exit 退出。<br>绝大部份项目中采用的会是第二种。注意pthread_cancel只是告知操作系统要取消线程1，但系统不会马上取消，而是等待线程1点代码运行到了一个取消点才会取消该进程。POSIX定义了一些取消点。一般能引起线程阻塞的函数都是取消点，比如sleep, open, wait, recvmsg等函数。</p>
</li>
<li><p>线程退出资源回收：当调用pthread_create创建子线程时，系统会给子线程分配相关资源，当子线程退出时，资源需要安全回收。<br>（1）可以在创建子线程之后，使用 pthread_join函数，等待子线程退出，线程退出后该函数才返回。<br>（2）可以调用函数 pthread_detach 使进程分离， 此时就不需要调用 pthread_join了，当线程退出时，系统会自动回收此线程的所有资源，但如果想要子线程一直运行，那么主线程必须不能退出。</p>
</li>
<li><p>线程私有数据<br>大公司面试中可能会出现。<br>线程私有数据也叫线程特定数据，是存储和查找某个线程相关数据的一种机制，每个线程都可以访问它自己的数据副本，而不需要担心与其它线程的同步问题。<br>线程的私有数据包括：<br>（1）errno：errno是系统调用失败时设置的值，为了让线程也能够使用那些原本基于进程的系统调用，errno被重新定义为线程私有数据。这样一个线程重置了errno的值，也不会影响其他线程或者进程的errno值。<br>（2）栈，可以被其他进程访问，但仍可认为是私有数据。即线程函数里的局部变量是线程私有数据。<br>（3）寄存器<br>（4）调度优先级和策略<br>（5）线程ID<br>（6）信号屏蔽字：创建线程的时候，线程继承了进程的信号屏蔽字，但是线程也可以使用 pthread_sigmask 修改自己的屏蔽字。</p>
</li>
<li><p>线程状态<br>创建状态（NEW），就绪状态（READY），运行状态（RUNNING），等待状态或阻塞状态（BLOCKED），结束状态（EXIT）。<br>会画线程状态变化图。</p>
</li>
<li><p>线程重命名<br>为了区别同一进程下的多个线程，可通过以下代码为线程命名：<br><code>prctl(PR_SET_NAME, &quot;THREAD_NAME&quot;)</code><br>调用此函数时，必须包含头文件 <code>#include&lt;sys/prctl.h&gt;</code></p>
</li>
<li><p>段错误(Segmentation fault)<br>一个线程在链表中插入节点，另一个线程取出节点，由于CPU是基于时间分片对线程进行调度的，可能插入操作进行到一半就切换到另一个线程进行删除操作，这样当数据不一致时可能会访问非法内存，产生段错误。</p>
</li>
<li><p>两个线程同时操作一个数据链表或者数据对象，叫做线程同步，或者并行操作。解决步骤：<br>（1）向系统申请锁: pthread_mutex_init 函数<br>（2）获取锁并上锁：pthread_mutex_lock 函数，如果函数返回说明上锁成功，如果一直不返回表示无法获取到锁，可能发生了死锁；<br>（3）解锁：pthread_mutex_unlock函数，加锁之后一定要解锁，只有解锁了其他进程才能获取到锁。</p>
</li>
<li><p>死锁：两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信造成的一种阻塞的现象。此时称系统处于死锁状态，这些互相等待的线程称为死锁线程。死锁发生的四个必要条件：<br>（1）互斥条件，即线程需要在一段时间内独占资源<br>（2）请求和保持条件，即线程至少已保持一个资源，又提出了新的资源请求，但该资源被其他线程占用。又都对自己的资源保持不放。<br>（3）不剥夺条件：即线程在使用完资源后自己释放，中途不能被剥夺。<br>（4）环路等待条件：必然形成环路 p0-p1-p2-…-pn-p0.</p>
</li>
<li><p>只要打破四个必要条件之一就能有效预防死锁的发生。在面试中，锁、死锁、死锁的必要条件、怎样预防死锁是必然会涉及的。</p>
</li>
<li><p>锁的类型：互斥锁（常用）、读写锁、旋转锁、递归锁、信号量</p>
</li>
</ol>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol>
<li><p>进程：进程是一个具有独立功能的程序。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。不只是程序代码，还包括当前的活动。UNIX系统中的两个特殊进程：<br>pid=0的进程：调度进程，是内核的一部分，它的功能是调度其他进程<br>pid=1的进程：init进程，在自举（自己检查自己后激活自己）结束时由内核调用，该进程负责启动一个unix系统。init进程绝对不会终止，它是第一个普通的进程（相对于内核进程），它是以root身份运行的。</p>
</li>
<li><p>可执行文件解析<br>进程运行后在内存的分布：</p>
<blockquote>
<p>内核虚拟存储器           —–高地址<br>用户栈<br>堆<br>未初始化数据段<br>初始化数据段<br>正文段                  —-低地址</p>
</blockquote>
</li>
</ol>
<p><strong>正文段</strong>：代码区，存放机器指令，父子进程共享它，一个进程多次运行也共享它，它是只读的。<br><strong>初始化数据段</strong>：通常称为数据段（data），<strong>初始化</strong>的变量放在这里，如全局变量，静态变量，常量（const修饰的变量）等等，前提是他们在定义的时候就被赋值了，如果这些变量没有初始化，那么就不存放在此处。<br><strong>未初始化数据段</strong>：通常称为bss段，在程序执行之前，内核将此段中的数据初始化为0，或者NULL，<strong>未初始化</strong>的全局变量就放在这里。<br><strong>堆</strong>：通常在堆中进行动态存储空间的分配，之前我们用malloc函数分配内存，就在此处管理。<br><strong>栈</strong>：自动变量和每次<strong>函数调用</strong>所需保存的信息都存放在此处。栈的空间是有限的，所以临时变量不能占用太多空间，比如在一个函数里，不要定义一个超大的数组，如果要空间，就用malloc申请。用命令<code>ulimit -s</code>可以查看栈的空间，可以在配置文件中修改栈的空间大小，但一般不建议修改。<br><strong>内核虚拟存储器</strong>：对用户代码而言不可见的存储器，有些地方也叫它内核的指令和环境变量区。</p>
<ol>
<li><p>可执行文件存储映像<br>Linux下面，目标文件、共享对象文件、可执行文件都是使用ELF文件格式来存储的。程序经过编译之后会输出目标文件，然后经过链接得到共享对象文件或者可执行文件。<br>代码和数据是分开存放的，这样设计的原因在于：<br>（1）代码一般是只读的，而数据是可读可写的。<br>（2）现代CPU一般有强大的缓存体系，程序和代码分离可以提高程序的局部性，增加缓存命中的概率。<br>（3）若有多个程序副本在运行，只读部分可以在只内存中保留一份，可以大大节省内存。<br>在ELF的定义中，把它们分开存放的地方称为一个Section，就是一个段。一个ELF文件中重要的段包括：<br>.text段：存储只读的程序，<br>.data段：存储已经初始化的全局变量和静态变量，<br>.bss段：存储未经初始化的全局变量和静态变量，因为这些变量还未初始化，所以这个段在文件当中不占据空间，<br>.rodata段：存储只读数据，比如字符串常量。<br>代码编译好后，可以用 file命令来查看编译好的文件信息。</p>
</li>
<li><p>问题：对于全局变量，即使我不初始化，系统也会自动将其初始化，那么我们编程的时候到底应不应该将其初始化呢？<br>最好养成初始化的习惯，对于不想给别的文件使用的全局变量，尽量使用 static 修饰。</p>
</li>
<li><p>问题：为什么要把可执行文件分为数据段和代码段？<br>因为对计算机而言，“指令”和“数据”都是二进制比特流，没有任何区别。采用指令和数据分开存放的方法，在代码段读到的统一被解释为机器指令，在数据段读到的统一解释为操作数。这样就能把代码和数据区分开来了。</p>
</li>
<li><p>fork函数<br>fork函数的功能是创建一个子进程，奇妙之处在于一次调用，两次返回，它可能有三种不同的返回值：<br>（1）在父进程中，fork返回新创建子进程的进程ID；<br>（2）在子进程中，fork返回0，这个时候子进程的名称与父进程的名称是相同的，但进程号pid是不同的；<br>（3）如果出现错误，fork返回一个负值；内存不足或者用户已到达最大进程数时，fork才会失败。<br>一般来说，fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。</p>
</li>
<li><p>vfork函数<br>用于创建一个子进程，而该进程的目的是调用exec相关函数执行一个新程序。<strong>特别需要注意的是</strong>，在子进程调用exec之前，它都运行在父进程空间，这种优化工作在某些unix的页式虚拟存储器实现中提高了效率。<br>vfork与fork的另外一个区别是，vfork保证子进程先运行，在它调用exec相关函数之后父进程才可能被调度运行（注意产生死锁）。</p>
</li>
<li><p>exit函数<br>功能：关闭所有文件，终止正在运行的程序<br>头文件：stdlib.h<br>说明：<br>（1）exit函数会调用_exit函数；<br>（2）exit(0)表示正常退出，exit(x)（x不为0）都表示异常退出，正常退出与main中调用return是一样的。<br>（3）return和exit()的另一个区别在于，即使在main()之外的函数中调用exit()，它也将终止程序。<br>（4）当最后一个线程从其启动例程返回时，该进程以终止状态0返回。<br>（5）进程的最后一个线程调用pthread_exit函数，进程终止状态总是0，这与传送给 pthread_exit的参数无关。</p>
</li>
<li><p>exit与_exit不同<br>（1）在由fork创建的子进程分支里，正常情况下使用exit是不正确的，因为它会导致标准输入输出的缓冲区被清空两次。还有一些特殊情况，比如守护程序，他们的父进程需要调用 _exit 而不是子进程；适用于绝大多数情况的基本规则是， exit 在每次进入main函数后只能调用一次。<br>（2）_exit 函数不执行标准IO的刷洗操作。我们知道，printf，fopen，fwrite这些函数，在内存中都有缓冲区，有时我们写入了文件，但实际上它还在缓冲区，这是如果用 _exit 直接将进程关闭，缓冲区中的数据就会丢失。如果要保持数据的完整性，就一定要使用exit函数。</p>
</li>
<li><p>多进程控制<br>控制进程p1和进程p2并发运行的流程（从p1转换到p2）：<br>（1）执行完进程转换前的最后一条指令；<br>（2）保留当前进程p1的上下文（context），这些信息保留在PCB（进程控制块）里；<br>（3）调用调度模块（scheduler）选择下一个要运行的进程p2；<br>（4）恢复p2的context（从其PCB里读取）；<br>（5）开始执行p2的指令。<br>上述过程也叫进程切换过程。</p>
<blockquote>
<p>为了描述控制进程的运行，系统为每个进程定义了一个数据结构——进程控制块（PCB），它是进程实体的一部分，是操作系统中最重要的记录性数据结构，用于描述进程的当前情况以及控制进程运行的全部信息。<br>系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是别的东西来感知到进程存在的。所以PCB是进程存在的唯一标志。</p>
</blockquote>
</li>
<li><p>僵尸进程<br>当进程由于某种原因终止时（包括正常终止），内核并不是立即把它从系统中清除，而是将此进程保持在一种已终止的状态，直到它的父进程将其回收。一个终止了但还未被回收的进程称为僵尸进程。</p>
</li>
<li><p>避免僵尸进程的方法<br>（1）父进程为子进程收尸（wait函数和waitpid函数）<br>（2）杀死父进程，僵尸进程会成为“孤儿进程”，系统会自动将其过继给1号进程init，init会负责回收僵尸进程<br>（3）父进程显式忽略SIGCHLD信号（不同内核版本可能有差别）<br>（4）fork两次，然后祖父进程杀死父进程，这样孙子进程就被init接管。</p>
</li>
<li><p>只有程序运行起来了，才能称之为进程，这是一个动态的概念。所以进程的状态包括三种：运行态（正在被CPU执行）、就绪态（可运行，但尚未分配到CPU）、阻塞态</p>
</li>
<li><p>exit(0)，exit(1)，与 return 的区别<br>exit(0): 正常运行程序被退出程序<br>exit(1): 非正常运行导致退出程序<br>return: 返回函数，若在主函数中，则会退出函数并返回值</p>
<blockquote>
<p>return是关键字，而exit是一个函数<br>return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示了一个进程的结束<br>return是函数的退出，而exit是进程的退出<br>return是C语言提供的，exit是操作系统提供的<br>非主函数调用中，return和exit的区别很明显</p>
</blockquote>
</li>
<li><p>面试题</p>
<blockquote>
<p>请问子进程自父进程继承了什么？未继承什么？<br>一般面试会是选择题，需要记住，子进程从父进程继承了大部分资源，但不包括：<br>（1）父进程的文件锁<br>（2）pending alarms（未处理闹钟）<br>（3）pending signals（未处理信号）<br>（4）进程ID和父进程ID<br>《UNIX环境高级编程》（P184）8.3 fork函数 全部有提到。</p>
</blockquote>
</li>
<li><p>虚拟地址空间是真实存在的吗？为什么？<br>虚拟地址空间不是真实存在的，每个进程都有自己的虚拟地址空间，每个进程都有一个叫作堆的虚拟地址，这个空间很大。堆就是虚拟出来的地址空间，我们调用malloc函数申请内存的时候就是向堆申请的。malloc成功返回时，这个返回值只是虚拟地址空间（堆空间）的大小，但不是真正内存的大小。当你申请成功之后，往其中读写数据时，操作系统才会把真正的内存空间分给堆空间，形成一种映射关系。</p>
<blockquote>
<p>malloc出来的内存就是进程所占用的内存吗？<br>不是，只有往里面读写数据时，系统才会把真正的内存空间分配给进程。</p>
</blockquote>
</li>
<li><p>linux的交换分区类似于windows的虚拟内存，当内存不足时，把一部分硬盘空间虚拟成内存使用，从而缓解内存紧张的情况。</p>
</li>
<li><p>简单描述一下应用可执行文件运行启动的过程是怎样的？<br>比如可执行文件test，当在shell中键入 ./test 之后：当前shell进程fork出一个子进程（子shell），子进程使用execve来脱离和父进程的关系，加载test文件（ELF格式）到内存中。如果test使用了动态链接库，就需要加载动态链接器（或者叫程序解释器），进一步加载test使用到的动态链接库到内存，并重定位以供test调用。最后从test的入口地址开始执行test。</p>
</li>
<li><p>wait函数<br>wait函数应该与fork函数成套出现，并且总是出现在fork函数之后。<br>子进程退出时会发出SIGCHLD信号，默认情况总是忽略SIGCHLD信号，子进程状态仍保留在内存中。但父进程直到使用wait函数时才收集状态信息并将其清空。用wait来等待一个子进程终止运行称为回收进程。注意，当没有子进程退出的时候，程序运行到wait就会一直阻塞；当所有子进程都已退出或者没有子进程时，wait直接返回 -1。</p>
</li>
<li><p>回收子进程的代码实现有两种方法，一种叫<strong>主动扫描</strong>，简单，但是会导致父进程阻塞，效率低下，另外一种叫<strong>触发</strong>，稍复杂，但是效率高。做项目时建议采用触发方式。</p>
<blockquote>
<p>主动扫描的代码： project_process_lizi/process004.c ，直接在父进程主函数使用wait<br>触发的代码： project_process_lizi/process005.c ，原理是注册一个处理SIGCHLD信号的函数，当父进程收到SIGCHLD信号的时候，调用该函数来处理</p>
</blockquote>
</li>
<li><p>上述触发代码仍然存在的问题：如果父进程创建的过多，而同一时间有很多子进程退出时，有些信号在系统队列里面可能会被丢弃，而使处理函数不能响应，产生僵尸进程，导致资源泄漏。process006演示了这种情况。</p>
</li>
<li><p>哎呀，一直傻不拉几的以为，子进程会执行父进程所有的代码，就是我因为错误的理解了一句话“子进程是父进程的完全拷贝”，这句话，理解错的原因是因为认为拷贝只是简单的“父进程程序的拷贝”，其实子进程拷贝父进程，包括拷贝父进程的一切有关信息，包括状态信息，当然就有程序计数器PC也在内了，所以在父进程执行到fork的时候，它的程序计数器的PC内容绝对不会是从main函数开头执行的了，其实PC此时存放的是进程下一条要执行的指令地址，所以子进程总是从fork之后开始执行。<br>所以一定要正确的理解进程的“动态”，所谓的动态就是体现在这儿了。<br>但是子进程和父进程的数据段是独立的，代码段是共享的。<br>一个简单的想法就是：<br>fork确实创建了一个子进程并完全复制父进程，但是子进程是从fork后面那个指令开始执行的。<br>对于原因也很合逻辑，如果子进程也从main开头到尾执行所有指令，那它执行到fork指令时也必定会创建一个子子进程，如此下去这个小小的程序就可以创建无数多个进程可以把你的电脑搞瘫痪</p>
</li>
<li><p>为了解决丢失信号的情况，引入 waitpid 函数（process008.c）<br>定义： <code>pid_t waitpid(pid_t pid, int* status, int options);</code><br>waitpid函数的功能比wait函数的功能要强大得多。<br>第一个参数pid：（1）pid&gt;0时只等待ID等于pid的子进程，只要指定的子进程还没有结束，waitpid就会一直阻塞下去；（2）pid＝0时，等待同一进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬；（3）pid=-1时，等待任何一个子进程退出，此时waitpid和wait的作用一样；（4）pid&lt;-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。<br>第三个参数options：（1）WNOHANG：即使没有子进程退出，它也会立即返回，不会像wait那样永远等待下去；（2）WUNTRACED：阻塞执行，直到子进程进入暂停或者进程终止。<br>waitpid的返回值：<br>（1）正常返回时，waitpid返回收集到的子进程的进程ID；<br>（2）如果设置了选项WHOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；<br>（3）如果调用中出错，则返回－1，这是errno会被设置成相应的值以指示错误所在；<br>（4）当pid指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD.</p>
</li>
<li><p>waitpid函数提供了wait函数没有的三个功能：<br>（1）waitpid可等待一个特定的进程，而wait则返回任一终止的进程的状态；<br>（2）waitpid提供了一个wait的非阻塞版本，有时希望获取一个子进程的状态，但不想阻塞；<br>（3）waitpid通过WUNTRACED和WCONTINUED选项支持进程控制。</p>
</li>
</ol>
<h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><ol>
<li><p>先回顾一下多线程：进程与线程有本质的不同，进程有独立的地址空间，而线程没有。线程间通信可以非常简单，比如定义一个全局变量，另外在两个线程需要同步的时候增加一些锁的操作就可以了。在线程技术尚不成熟时，人们普遍采用多进程来完成项目。</p>
</li>
<li><p>进程间通信（IPC）主要有以下几种方式：</p>
<blockquote>
<ul>
<li>管道</li>
<li>共享内存</li>
<li>信号量</li>
<li>消息队列</li>
<li>信号</li>
<li>套接字</li>
</ul>
</blockquote>
</li>
<li><p>管道：管道的实现并没有使用专门的数据结构，两个进程只是打开同一个文件（open），一个进程写入（write），一个进程读出（read）。进程间通讯的管道分为无名管道和有名管道。</p>
</li>
<li><p>无名管道：半双工，同一时间数据只能单向流动，而且只能在具有亲缘关系（父子关系）的进程间使用。所谓无名，就是对用户不可见，只在内存中创建，不写入磁盘。<br>函数原型：<code>int pipe(int pipe_fd[2]);</code><br>功能：创建无名管道<br>pipe_fd： 数组名，一个长度为2的int数组，pipe_fd[0]用作读， pipe_fd[1]用作写<br>返回值：成功返回0，失败返回－1，并且pipe_fd会被赋值</p>
</li>
<li><p>有名管道（命名管道）：也是半双工，但它允许无亲缘关系的进程间的通信。（name_pipe_read.c与name_pipe_write.c）<br>函数原型： `int mkfifo(const char* pathname, mode_t mode);｀<br>功能：创建命名管道<br>pathname：文件路径<br>mode：标志，包括打开模式与权限<br>返回值：成功则返回0，否则返回－1，错误原因存于errno中。</p>
</li>
<li><p>管道说明：<br>（1）管道就是对文件的操作，一端读，一端写，但这个文件占用内存的大小是有限制的；<br>（2）读写具有互斥性，调用者不必关心数据的同步问题，因为内核用锁来实现了读写的互斥问题；<br>（3）支持多进程读写操作；<br>（4）可以设置阻塞与非阻塞，默认是阻塞的。所谓阻塞，就是如果一端一直写，而另一端不读，待内存写满后，write函数就会阻塞，直到写入成功才返回。<br>（5）设置阻塞标志时（默认），调用mkfifo后，管道的两端必须都打开，如果有一方未打开，那么在调用open的时候会阻塞；<br>（6）设置非阻塞标志时，如果希望打开管道的写端，则先需要另一个进程打开该管道的读端，即写进程必须在读进程之后，否则写端的open将失败。</p>
</li>
<li><p>共享内存<br>一般而言，每个进程有自己独立的资源，不能相互访问。但可以借助操作系统来使用共享内存。<br>共享内存是进程间通信的一种方式，此方式会开辟一部分可以被多个进程共享访问的物理内存区域，进行通信的多个进程分别将该内存区域映射到自己的虚拟地址空间，从而实现访问和通信。<br>ftok 是一个系统库函数，它的作用是告诉操作系统，本进程要建立IPC通讯，想操作系统申请一个key值。</p>
<blockquote>
<p>原型： <code>key_t ftok(const char* fname, int id)</code><br>参数fname：文件路径<br>参数id：ftok函数根据这个id值返回不同的key值。<br>利用库函数shmget来创建、获取指定的共享内存ID。<br>原型： <code>int shmget(key_t key, size_t size, int shmflg)</code><br>参数size：设置共享内存的大小<br>参数shmflg：标志位<br>返回值：共享内存ID<br>利用shmat，把共享内存映射到自己的进程中来，之后就可以直接使用这段内存空间了。<br>原型： <code>void * shmat(int shmid, const void * shmaddr, int shmflg)</code><br>参数shmid：共享内存ID<br>参数shmaddr：指定共享内存出现在进程内存地址的什么位置，通常指定为NULL，让内核自己决定一个合适的位置<br>参数shmflg：SHM_RDONLY为只读模式，其他为读写模式<br>返回值：返回本进程可用的<strong>地址指针</strong>，这样后面的代码就可以直接使用共享内存了。</p>
</blockquote>
</li>
<li><p>依次采用上面三个函数就可以实现共享内存的创建、访问了，除此之外还了解一下 shmctl （控制管理共享内存）函数和 shmdt（断开共享内存映射链接） 函数</p>
</li>
<li><p>共享内存相关的shell命令：<br>查看共享内存： <code>ipcs -m</code><br>删除共享内存：<code>ipcrm -m shmid</code></p>
</li>
<li><p>共享内存的优缺点<br>优点：读写速度快<br>缺点：各进程对共享内存的操作不互斥，存在数据同步问题（可利用信号量等工具解决）。</p>
</li>
<li><p>信号量(P操作与V操作)<br>同步：多个进程为了完成同一个任务相互协作，就形成了同步关系。<br>互斥：不同进程为了争夺有限的硬件或软件资源会进入竞争状态，而这个资源在某时刻只允许一个进程使用，这就是进程间的互斥关系。<br>临界资源：在同一时刻只允许有限个（通常只有一个）进程可以访问的资源。访问临街资源的代码叫临界区，临界区本身也会成为临界资源。<br>信号量就是用来解决同步与互斥问题的一种通信机制，与之前介绍的线程锁的作用是一样的，但是功能更强大，不仅可用在多线程，更多地用在多进程。<br>创建信号量的过程与创建共享内存是类似的，首先利用ftok获取一个key。<br>再利用 semget 函数创建或获取指定的信号量</p>
<blockquote>
<p>原型：<code>int semget(key_t key, int nsems, int semflg);</code><br>利用semctl 函数设置信号量的值<br>原型： <code>int semctl(int semid, int semnum, int cmd, union union_arg);</code><br>利用semop函数来操作信号量<br>原型： <code>int semop(int semid, struct sembuf *sops, size_t nsops);</code></p>
</blockquote>
</li>
<li><p>面试的时候会问到P操作与V操作<br>在进程间通信的时候，如果采用信号量来进行同步操作，那么信号量就是采用P、V操作来实现的。所谓的P操作，就是将信号量减1，而V操作，就是将信号量加1，如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞进程。</p>
</li>
<li><p>信号量shell调试命令：<br>显示当前所有信号量信息： <code>ipcs -s</code><br>删除信号量： <code>ipcrm -s semid</code></p>
</li>
<li><p>消息队列<br>定义：多个独立的进程之间可以通过消息缓冲机制来相互通信。这种通信的实现是以消息缓冲区为中间介质。通信双方的发送和接收操作均以消息为单位。在存储器中，消息缓冲区被组织成队列。消息队列一旦创建后即可由多进程共享。发送消息的进程可以在任意时刻发送任意数量的消息到指定的消息队列上，并检查是否有接受进程在等待它所发送的消息，若有则唤醒它。内核（操作系统）就是用链表来管理这些消息的。<br>特点：<br>（1）有些地方也叫数据报，发送和接收是以数据报为单位进行的。<br>（2）消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。<br>使用过程：<br>（1）利用ftok函数获取key<br>（2）利用msgget函数建立消息队列，并返回 msgid<br>（3）利用msgsnd函数向队列发送数据，利用msgrcv函数从队列中获取消息<br>（4）利用msgctl函数控制管理队列（比如进行删除操作）</p>
</li>
<li><p>使用消息队列需要注意的地方<br>（1）消息队列的读写在内核中已经解决了数据同步的问题，编程时不用担心<br>（2）Linux使用宏MSGMAX和MSGMNB来限制一条消息的最大长度和一个队列的总长度，分别是8192、16384<br>（3）发送和接收可以通过标志位设置阻塞模式和非阻塞模式，默认是阻塞</p>
</li>
<li><p>消息队列的缺点：<br>消息队列的读写需要消耗cpu的额外资源，不适合信息量大和操作频繁的场合。</p>
</li>
<li><p>消息队列调试的系统命令：<br>显示当前所有消息队列信息: ipcs -q<br>删除消息队列： ipcrm -q msgid</p>
</li>
<li><p>信号<br>信号与信号量不是同一个概念，功能与作用都不同，不能混淆。<br>每个信号的名字都是以SIG开头的，一个进程接收到信号之后，会立刻停止正在执行的程序（中断），去执行信号处理函数。<br>硬中断、软中断的概念。<br>使用方法：注册信号处理函数，捕捉信号。如果没有定义自己的信号处理函数，则按系统默认方式处理。<br>部分常见信号：<br>子进程状态的改变，比如创建、终止，系统会向父进程发送SIGCHLD信号；<br>踩地址（段错误），系统给进程发送SIGSEGV信号；<br>kill杀死进程，系统给进程发送SIGTERM信号；<br>CTRL+C退出，系统给进程发送SIGINT信号；<br>调用定时器alarm，信号是SIGALRM；<br>系统关机时，系统给每个进程发送SIGTERM信号；<br>TCP链接断开，套接字无效了，系统给进程发送 SIGPIPE信号。</p>
</li>
<li><p>信号需要注意的地方<br>（1）所有信号必须经过操作系统转发。<br>（2）信号就是一种软件中断，对于一般的操作系统，如果在信号处理函数的执行过程中又收到同一个进程的同一个信号，则会之间将其丢弃。我们编程时应该认为信号是不可靠的（即可能发生信号丢失）。<br>（3）信号名称是由操作系统规定好的，不同操作系统可能有差别。<br>（4）信号在实际项目中使用较少，可能出于以下原因：携带的信息量太少；中断程序的正常运行；如果信号太过频繁，进程间的强制切换会占用较多的CPU资源<br>（5）面试的时候，可能会问：你用过或者知道哪些信号？</p>
</li>
<li><p>套接字：进程间通过网络连接进行通信。</p>
</li>
<li><p>进程间通信总结<br>（1）管道：通过文件的形式来进行读写，操作过程需要遵循文件的操作过程；<br>（2）消息队列：内核实现了读写的同步问题，效率较高，但是消息队列所能容纳的数据量较小，另外系统要分配额外的内存来存储用户的数据；<br>（3）信号：实时性比较强，但会打断程序的正常运行过程，如果过多的话，内核进程的切换会消耗较多的CPU资源，另一个问题是所能携带的数据太少；<br>（4）共享内存：读写效率最高，但内部没有实现读写的同步，给编程带来一定的麻烦；<br>（5）信号量：P、V操作，不能携带数据；<br>（6）套接字：易扩展、易移植、跨平台性好， 缺点是：数据通信的效率很低，稳定性较差（受网络环境影响）。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yanggang.site/2016/09/03/dataStructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="东坡烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/03/dataStructure/" itemprop="url">
                  数据结构要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-03T18:56:29+08:00">
                2016-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。 数据结构意味着介面或封装：一个数据结构可被视为两个函数之间的介面，或者是由数据类型联合组成的存储内容的访问方法封装。 大多数数据结构都由数列、记录、可辨识联合、引用等基本类型构成。</p>
<p>  大中型服务器软件一般应考虑以下几点：</p>
<blockquote>
<ul>
<li>数据的安全性</li>
<li>结构清晰（尽量减少耦合）</li>
<li>易扩展性</li>
<li>易使用</li>
<li>易维护、易升级（日志信息充分，易定位问题）</li>
<li>数据的处理效率</li>
<li>平台的可移植性</li>
<li>保证性能的前提下，尽量少占用CPU和内存</li>
</ul>
</blockquote>
<ol>
<li><p>手写链表，要注意头节点、尾节点的操作，还有参数的合法性，都是得分点，不可大意。</p>
</li>
<li><p>队列的原理在实际项目中非常广，栈的应用多在库函数中，实际项目比较少见。</p>
<blockquote>
<p>经典题：如何用两个栈实现队列的功能？</p>
</blockquote>
</li>
<li>实现队列有单链表和双链表两种方法。<br>单向链表实现队列可以从头部增加节点，从尾部删除节点，也可以反过来。但是必然有一个操作要遍历整个列表，效率低。因此可采用双向循环链表，减少查询链表尾节点的时间。代价是内存上需要在每个节点上增加一个指针，一个指针在32位系统上占4个字节，如果最大支持1万个节点，那么将比单向链表多占用40M空间，这点内存对于大型服务器软件来说，完全可以忽略不计。</li>
<li><p>一般会采用三种方法来遍历一棵二叉树，前序遍历、中序遍历、后序遍历。<br>前序遍历：（1）根节点，（2）左子树所有节点，（3）右子树所有节点。（子树同样采用前序遍历）<br>中序遍历：（1）左子树所有节点，（2）根节点，（3）右子树所有节点。（子树同样采用中序遍历）<br>后序遍历：（1）左子树所有节点，（2）右子树所有节点，（3）根节点。（子树同样采用后序遍历）</p>
</li>
<li><p>排序二叉树（二叉查找树）<br>特点：<br>（1）左子树节点全部小于根节点的值，右子树节点全部大于根节点的值；<br>（2）没有键值相等的节点；<br>（3）子树也是排序二叉树。</p>
</li>
<li><p>平衡二叉树：节点左子树的高度与右子树的高度相差不超过 1<br>插入新数据可能导致二叉树不平衡，无法得到比链表更高的效率，因此需要平衡算法。当树很大的时候平衡算法很复杂。</p>
</li>
<li><p>二分查找算法：每次查询某数字都与数组中间的元素进行比较。</p>
<blockquote>
<p>面试：二分查找的递归实现和非递归实现（要熟练）。</p>
</blockquote>
</li>
<li><p>运行查找算法的前提条件：（1）数据必须要有序，（2）数据必须是放在连续的存储空间里面的。</p>
</li>
<li><p>哈希查找<br>哈希散列算法：按照某种规律把具有相同特性的数据进行分组，这样就有很多组了，或者说很多列了，而这些列之间是没有任何关系的，所以叫散列。<br>比如：把学生按学号除以11的余数不同，将其分为11个组。<br>哈希表中存放列表地址的数组称为桶（bucket）。比起链表算法，哈希算法需要多用一些存储空间，这个存储空间就是桶的存储空间。</p>
</li>
<li><p>静态查找表、动态查找表</p>
</li>
<li><p>异或操作交换两个变量的数据：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a<span class="string">[i]</span> = a<span class="string">[i]</span> ^ a<span class="string">[i+1]</span>;</div><div class="line">a<span class="string">[i+1]</span> = a<span class="string">[i]</span> ^ a<span class="string">[i+1]</span>;</div><div class="line">a<span class="string">[i]</span> = a<span class="string">[i]</span> ^ a<span class="string">[i+1]</span>;</div></pre></td></tr></table></figure>
<p>但要注意，如果两个变量值相等则不能使用此方法，因为异或会得到0.<br>当然，交换变量值也可以用以下代码实现：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">a</span> = a + b;</div><div class="line"><span class="attribute">b</span> = a - b;</div><div class="line"><span class="attribute">a</span> = a - b;</div></pre></td></tr></table></figure>
<p>但是，这种做法有个致命缺陷，就是越界问题。软件工程师在使用加减乘除时要时刻注意是否存在越界问题。</p>
</li>
<li><p>冒泡排序、选择排序、快速排序</p>
</li>
<li><p>一般来说，二分算法在笔试里经常出现，而哈希算法在第二轮面试里经常出现。二分算法查找效率很高 log2(n)，但必须保证整个数据在内存空间是连续的，当删除一个数据时，需要把后面的数据都往前挪一个位置，当数据多的时候比较消耗CPU。所以，二分算法适合那些不需要经常增删改的数据，比如全国行政区划列表。而哈希算法适合那些经常增删改的数据，对哈希表操作类似于对链表进行操作，虽然其效率比二分差，但总体来说还是不错的。</p>
</li>
<li><p>字节对齐<br>基本是面试必考题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> employee&#123;</div><div class="line">    <span class="keyword">char</span> sex;</div><div class="line">    <span class="keyword">int</span> length;</div><div class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</div><div class="line">&#125; em_st;</div></pre></td></tr></table></figure>
<p>请问<code>sizeof(em_st)</code>的值是多少？很多人会回答15，其实并不是。<br>在定义的数据结构中，如果出现了三种基本的数据类型 char, short int , int ,我们就以占用内存最大的那个作为字节对齐的方式。比如只有char、short int时，就以2字节对齐。只有char，就以1字节对齐。</p>
</li>
<li><p>结构成员变量中的位<br>有时候为了节省空间，结构体中的成员变量是按位操作的，比如</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct test&#123;</div><div class="line">    <span class="keyword">char</span> <span class="string">a:</span><span class="number">5</span>;   <span class="comment">// 第一字节的前5位</span></div><div class="line">    <span class="keyword">char</span> <span class="string">b:</span><span class="number">3</span>;   <span class="comment">// 第一字节的后3位</span></div><div class="line">    <span class="keyword">char</span> <span class="string">c:</span><span class="number">8</span>;   <span class="comment">// 第二字节的前8位</span></div><div class="line">    <span class="keyword">char</span> <span class="string">d:</span><span class="number">2</span>;   <span class="comment">// 第三字节的前2位</span></div><div class="line">    <span class="keyword">char</span> <span class="string">e:</span><span class="number">6</span>;</div><div class="line">    <span class="keyword">char</span> <span class="string">f:</span><span class="number">7</span>;</div><div class="line">    <span class="keyword">char</span> <span class="string">g:</span><span class="number">1</span>;</div><div class="line">&#125; test_em;</div></pre></td></tr></table></figure>
<p>IP地址就可以采用这种形式来定义，比字符串更省空间。</p>
</li>
<li><p>更改系统默认的字节对齐<br>代码前加上 <code>pragma pack(4)</code> 就表示采用4字节对齐。当然，实际情况与系统、CPU、编译器版本都有关。一般记住默认以4字节对齐即可。</p>
</li>
<li><p><code>container_of</code>宏<br>内核最经典的宏。<br>作用：从结构体成员变量的指针获取整个结构体的指针。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yanggang.site/2016/09/01/c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="东坡烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/01/c/" itemprop="url">
                  C语言要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-01T17:55:25+08:00">
                2016-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C语言是C++的基础，广泛用于系统软件与应用软件的开发。Linux本身就是C语言的杰出作品，其重要性毋庸置疑。因此将复习C语言时自己注意到的要点记录于此。</p>
<ol>
<li><p>程序中对数字的引用，优先考虑无符号整型，其次是有符号整型、浮点型。整型要注意溢出问题（越界问题），浮点型要注意精度问题（一般float有效数字为6-7位）。例如，1.25元，尽量用整型125分表示。<br>对编程人员来说，double 和 float 的区别是double精度高，有效数字16位，float精度7位。但double消耗内存是float的两倍，double的运算速度比float慢得多，C语言中数学函数名称double 和 float不同，不要写错，能用单精度时不要用双精度（以省内存，加快运算速度）。</p>
</li>
<li><p>字符常量’x’与字符串常量”x”的区别：(1)前者是基本型数据， 后者是构造型数据；（2）占用的存储空间大小不同，前者占1个字节，后者占2个字节（因为有’\0’）。</p>
</li>
<li><p>定义符号常量的方法：（1）宏定义，如 #define PI 3.14；（2）关键字const，如 const int MAX_NUMBER = 30, 这样 MAX_NUMBER是只读的。</p>
</li>
<li><p>C语言没有逻辑类型（bool），因此用整数1表示“真”， 用整数0表示“假”。</p>
</li>
<li><p>函数使程序模块化，好处在于：（1）分而治之，便于管理；（2）代码重用，提高效率；（3）抽象化，隐藏细节。</p>
</li>
<li><p>每个标准库函数都有对应的头文件，其中包含函数原型、参数类型和常量定义。</p>
</li>
<li><p>当实参列表中有多个实参时，对实参的求值顺序并不确定，VC和BC是按从右往左的顺序求值。比如调用函数 int max(int a, int b);时， max(x, x++) 的参数传递顺序为 b=x++; a=x; .</p>
</li>
<li><p>函数间参数的传递有两种类型：值传递和引用传递。在C语言中，所有参数传递都采用值传递。</p>
</li>
<li><p>变量定义的完整格式为： &lt;存储类别&gt; &lt;数据类型&gt; &lt;变量名&gt; ， 存储类别决定了变量在内存中持续的时间（生存期）和在硬件中存放的位置。</p>
</li>
<li><p>四种存储类别说明符： auto（自动变量）, register（寄存器变量）, extern, static。其中，auto和register为自动存储（执行到所在程序块时创建，退出程序块时销毁），extern和static为静态存储（程序一开始执行就创建，程序执行期间，即使退出所在程序块，变量也一直存在， 并保留值）。</p>
</li>
<li><p>关于作用范围<br>（1）全局变量、函数定义、函数原型等属于在函数外声明的标识符，其作用范围从声明的位置开始，到文件的末尾。称为文件作用范围。<br>（2）语句标号如 loop … goto loop, 只能在函数体内被引用。称为函数作用范围。<br>（3）局部变量在程序块内声明和使用。称为程序块作用范围。<br>（4）函数原型中的参数。函数原型作用范围。</p>
</li>
<li><p>声明分两种：定义声明（定义的同时也即声明，创建并分配内存）和引用声明（声明一个需要引用的标识符）。</p>
</li>
<li><p>全局变量可以被同一文件内的函数访问，如果需要被其他文件内的函数访问，则必须在其他文件中用extern声明。一个文件定义的函数也可以被其他文件内的函数调用，函数原型的声明可以不需要extern。</p>
</li>
<li><p>static关键字：<br>（1）修饰全局变量时，表示限制全局变量只能被同一文件内的函数访问（作用在于隐藏）；<br>（2）修饰函数定义时，表示限制函数只能被同一文件内的函数调用。<br>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。<br>总之，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</p>
</li>
<li><p>数组名是一个指针变量，其值是数组第一个元素的地址。将数组作为参数传递时（仍然是值传递），一般要同时把数组的长度传递给函数。输出指针地址的说明符为 “%p”。</p>
</li>
<li><p>字符串：在C语言中，字符串是存储在字符数组中并用空字符（’\0’）结束的字符序列，字符串名就是字符数组名。字符数组所有元素的缺省初值都是’\0’。</p>
</li>
<li><p>字符串指针： 指向字符串（字符数组）的指针。系统在编译时为字符串分配内存单元。</p>
</li>
<li><p>结构体不能包含自己的实例，但可以包含指向自身的指针。</p>
</li>
<li><p>与数组不同， 结构体的变量名不是指针。获取结构体的地址需要用 ‘&amp;’ 运算符。</p>
</li>
<li><p>结构体作为参数时：（1）若传递结构体名，则是值传递，被调用函数不能修改调用函数中的结构体；（2）若传递结构体指针，则是模拟引用传递，被调用函数可以修改函数中的结构体。</p>
</li>
<li><p>typedef：为已经定义的数据类型创建一个别名，例如 typedef struct date Date，即结构体struct date类型的别名是Date， 并非创建新类型。这样做可以简化程序代码，提高程序的可移植性。</p>
</li>
<li><p>srand(time(NULL)); 是拿当前系统时间作为种子产生随机数，由于时间是变化的，种子变化，可以产生不相同的随机数。</p>
</li>
<li><p>编译预处理：<br>（1）无参数的宏定义：必须写在函数之外，宏名的有效范围是从宏定义开始到本源程序文件结束，或遇到预处理命令 #undef 时止。宏定义不但可以定义常量，还可以定义C语句和表达式，并且不做任何语法检查。<br>（2）有参数的宏定义：格式为【 #define 宏名（形参表） 字符串】，例如 #define M(a,b) a*b.<br>（3）条件编译：控制代码段是否参加编译。指令有 #if, #ifdef, #ifndef, #else, #endif.</p>
</li>
<li><p><code>int main(int argc,char *argv[])</code> ,函数中int argc和argv[]两个参数的说明：<br>（1）argc：命令行总的参数的个数,即argv中元素的个数。<br>（2）*argv[ ]: 字符串数组,用来存放指向你的字符串参数的指针数组,每一个元素指向一个参数：<br>argv[0]:指向程序的全路径名；<br>argv[1]:指向在DOS命令行中执行程序名后的第一个字符串；<br>argv[2]:指向第二个字符串。</p>
</li>
<li><p>指针地址就是内存的一个编号，这个编号就是个整型常量，所以在32位机上用int（4字节）表示，在64位机上用long int（8字节）表示。</p>
</li>
<li><p>为什么指针要分类型？指针的类型决定了指针计算的度量单位，比如对<code>int *p</code>而言，p+1 和 p 相隔4个字节，对 <code>char *q</code>而言， q+1 和 q 相隔1个字节 。指针相减时的结果也以此度量，而非字节数，比如 p-q = 1，若为int型指针，则p和q所指向的地址相差4个字节。指针类型强制转换时尤其要注意这一点（可通过把结构体指针强转为char型指针，来使其每次移动1个字节）。</p>
</li>
<li><p>野指针：也就是指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。<br>“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。野指针的成因主要有两种：<br>（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。<br>（2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。<br>  参考文章：<a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/06/28/1766854.html" target="_blank" rel="external">http://www.cnblogs.com/yc_sunniwell/archive/2010/06/28/1766854.html</a></p>
</li>
<li><p>常见文件操作：（1）软件运行前：配置文件；（2）软件运行中：日志文件；（3）软件退出：数据文件。</p>
</li>
<li><p>文件操作的标准：（1）POSIX标准（没有缓存，如write函数，写到磁盘后返回成功，可靠性高，如银行系统）；（2）ANSI标准（优先操作缓存，如fwrite函数，写到内存后就返回成功，内存到磁盘由另外的程序完成，速度快）。<br>需要能讲清楚这两种标准的原理。</p>
</li>
<li><p>POSIX标准的文件句柄（ANSI标准的文件句柄实际上是文件指针）：在文件I/O中，要从一个文件读取数据，应用程序首先要调用操作系统函数并传送文件名，并选一个到该文件的路径来打开文件。该函数取回一个顺序号，即文件句柄（file handle），该文件句柄对于打开的文件是唯一的识别依据。要从文件中读取一块数据，应用程序需要调用函数ReadFile，并将文件句柄在内存中的地址和要拷贝的字节数传送给操作系统。当完成任务后，再通过调用系统函数来关闭该文件。返回的文件句柄值小于0时，说明调用失败了。</p>
</li>
<li><p>可以使用 _exit(0); 函数代替 return 0; 来模拟系统掉电的情形，即内存中的数据不会被写入磁盘。</p>
</li>
<li><p>内存分配方式有三种：<br>[1] 从静态存储区域分配。内存在程序 编译的时候就已经分配好，这块内存 程序 的整个运行期间都存在。例如全局变量， static变量。<br>[2]在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>[3]从堆上分配，亦称动态内存分配。 程序 在运行的时候用malloc或new申请任意多少的内存， 程序 员自己负责在何时用free或delete释放内存。动态内存的生存期由 程序 员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的 程序 会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></div><div class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局未初始化区</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> b; <span class="comment">//栈</span></div><div class="line"><span class="keyword">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">//栈</span></div><div class="line"><span class="keyword">char</span> *p2; <span class="comment">//栈</span></div><div class="line"><span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">//123456\\0在常量区，p3在栈上。</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></div><div class="line">p1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</div><div class="line">p2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</div><div class="line"><span class="comment">//分配得来得和字节的区域就在堆区。</span></div><div class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456\\0放在常量区，</span></div><div class="line"><span class="comment">//编译器可能会将它与p3所指向的\"123456\"优化成一个地方。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>不要malloc出一大片连续内存，然后用free操作其中的一小段内存，否则容易出错。应该从哪里malloc，就从哪里free。 (员工信息管理demo)</p>
</li>
<li><p>所有全局变量最好定义在头文件中一个单独的结构体中进行管理，结构体初始化采用 memset更专业。</p>
</li>
<li><p>除非对可靠性要求很高的场合，一般性项目中直接用 fread，fwrite即可，比read，write效率更高。</p>
</li>
<li><p>C++内存管理<br><a href="http://www.cnblogs.com/lancidie/archive/2011/08/05/2128318.html" target="_blank" rel="external">http://www.cnblogs.com/lancidie/archive/2011/08/05/2128318.html</a></p>
</li>
<li><p>Linux配置文件读取<br><a href="http://blog.csdn.net/zhouzhaoxiong1227/article/details/45563263" target="_blank" rel="external">http://blog.csdn.net/zhouzhaoxiong1227/article/details/45563263</a></p>
</li>
<li><p>C语言项目命名规范（匈牙利命名法）</p>
<ul>
<li>全局变量加前缀g_，如定义一个全局变量<code>int g_iVal</code>;</li>
<li>static变量加前缀s_，如定义一个模块全局变量<code>static int s_iVal</code>;</li>
<li>结构体变量加前缀st_,如COMM_PARA是一个已经定义好的结构体，则<code>COMM_PARA stCommPara</code>;</li>
<li>枚举变量加前缀e,如ENUM_SEX是一个已经定义好的枚举，则<code>ENUM_SEX eSex</code>;</li>
<li>int类型变量加前缀i,如<code>int iRet</code>;</li>
<li>unsinged int类型加前缀ui,如<code>unsigned int uiRetCode</code>;</li>
<li>float类型变量加前缀f,如<code>float fVal</code>；其实有了double类型，可以不用float，就尽量使用double。</li>
<li>unsinged float类型变量加前缀uf,如<code>unsinged float ufVal</code>；</li>
<li>double类型变量加前缀d,如<code>double dVal</code>；</li>
<li>unsinged double类型变量加前缀ud,如<code>unsinged double udVal</code>；</li>
<li>short int类型变量加前缀si,如<code>short siVal</code>；</li>
<li>unsinged short类型变量加前缀usi,如<code>unsinged short usiVal</code>；</li>
<li>如果定义一个bool类型的变量加前缀b,如<code>int bFlag; char bFlag;</code></li>
<li>对于字符串类型char[]，如果字符串是需要以0结束符的字符串，则<code>char szCountry[11+1]</code>，这种情况下的字符数组的大小写法是字符个数+1的；如果字符串不需要以0结束符的，则<code>char sCountry[11]</code>。</li>
<li>对于字符串类型<code>char *</code>，如果字符串是需要以0结束符的字符串，则<code>char *pszCountry</code>，这种情况下的字符数组的大小写法是字符个数+1的；如果字符串不需要以0结束符的，则<code>char *psCountry</code>。</li>
<li>对于指针类型，如果指针变量是通过malloc动态获取内存的，则<code>int * piValPtx</code>，Ptx代表这个变量是需要动态释放内存；如果指针变来那个不是动态获取内存的，则<code>int piValPtr</code>；如果带上了Ptr或者Ptx的后缀，则前缀的p可省略。</li>
<li>项目的命名在公司内唯一</li>
<li>文件的命名：如果某些文件是项目唯一使用的，则文件名称加上项目名称简写加上“_”作为前缀;</li>
<li>接口函数命名：如果写的是库，则库接口则应该是库名称加上项目名称简写加上“_”作为前缀。</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yanggang.site/2016/08/26/ordinary-road/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vincent">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="东坡烟尘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/26/ordinary-road/" itemprop="url">
                  平凡之路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-26T22:50:05+08:00">
                2016-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/emotion/" itemprop="url" rel="index">
                    <span itemprop="name">emotion</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>十年前，你说生命要如夏花般灿烂；十年后，你说平凡才是唯一的答案。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="http://music.163.com/outchain/player?type=2&id=29750099&auto=1&height=32"></iframe>


<blockquote>
<p><em>徘徊着的 在路上的<br>你要走吗 via via<br>易碎的 骄傲着<br>那也曾是我的模样<br>沸腾着的 不安着的<br>你要去哪 via via<br>谜一样的 沉默着的<br>故事你真的在听吗<br>我曾经跨过山和大海<br>也穿过人山人海<br>我曾经拥有着的一切<br>转眼都飘散如烟<br>我曾经失落失望失掉所有方向<br>直到看见 平凡才是唯一的答案<br>当你仍然 还在幻想<br>你的明天 via via<br>她会好吗 还是更烂<br>对我而言是另一天<br>我曾经毁了我的一切<br>只想永远地离开<br>我曾经堕入无边黑暗<br>想挣扎无法自拔<br>我曾经像你像他像那野草野花<br>绝望着 也渴望着 也哭也笑平凡着<br>向前走 就这么走<br>就算你被给过什么<br>向前走 就这么走<br>就算你被夺走什么<br>向前走 就这么走<br>就算你会错过什么<br>向前走 就这么走<br>就算你会<br>我曾经跨过山和大海<br>也穿过人山人海<br>我曾经拥有着一切<br>转眼都飘散如烟<br>我曾经失落失望失掉所有方向<br>直到看见 平凡才是唯一的答案<br>我曾经毁了我的一切<br>只想永远地离开<br>我曾经堕入无边黑暗<br>想挣扎无法自拔<br>我曾经像你像他像那野草野花<br>绝望着 也渴望着 也哭也笑平凡着<br>我曾经跨过山和大海<br>也穿过人山人海<br>我曾经问遍整个世界<br>从来没得到答案<br>我不过像你像他像那野草野花<br>冥冥中这是我 唯一要走的路啊<br>时间无言 如此这般<br>明天已在 hia hia<br>风吹过的 路依然远<br>你的故事讲到哪了</em></p>
</blockquote>
<p><img src="http://ocigeyw01.bkt.clouddn.com/md/img/road.jpg" alt="平凡之路" title="平凡之路"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Vincent" />
          <p class="site-author-name" itemprop="name">Vincent</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vincent</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
